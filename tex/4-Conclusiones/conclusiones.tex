\chapter{Conclusiones}

El objetivo principal de este proyecto, como se ha ido mencionando, es doble. Por una parte se busca analizar el área de la seguridad informática para ver su estado actual, desarrollo, y como cumple los objetivos para los que el campo ha sido desarrollado. Todo ese análisis ha quedado volcado en lo que se ha denominado \textit{Fase 1}. El análisis cubre de manera general el campo de la seguridad y va concretándose hasta una parte en concreto, que es la del Pentesting, una de las áreas más interesantes dentro de la seguridad informática en general y de la seguridad defensiva en particular.

En base a lo obtenido en dicha fase, el proyecto se ha centrado en ofrecer una solución a un problema más concreto. Solución que ha sido desarrollada en lo que se ha llamado \textit{Fase 2}. El objetivo principal de este proyecto no es la aplicación que ha sido desarrollada, sino todo el análisis del campo, las conclusiones, las pautas, razonamientos y toma de decisiones seguidas para intentar dar solución a un problema concreto.

En concreto, mostrar cómo se puede, tras analizar las problemáticas que pueden surgir en un campo, dotar de soluciones concretas que satisfagan las necesidades de los usuarios. En este área en particular, una de las mayores debilidades que se pueden apreciar es que, de alguna u otra manera, el propio usuario queda relegado a un papel secundario a la hora de garantizar su seguridad.

Está claro qué es un usuario no tiene los conocimientos necesarios como para actuar como un experto en seguridad, pero esto no quiere decir que tenga que jugar un papel puramente pasivo. De la misma manera que tenemos sistemas de apoyo a la decisión que no deciden por nosotros, sino que en base a herramientas informáticas desarrolladas por expertos, nos permiten tomar decisiones en diferentes campos (como puede ser, por ejemplo, el mercado bursátil), la idea con este proyecto es enseñar cómo se puede, mediante soluciones de software, dotar al usuario de información más clara y mejor estructurada. Información con la que pueda ser consciente de la seguridad de sus sistemas y actuar en consecuencia.

La aplicación desarrollada no pretende ser una solución final, sino más bien una prueba de concepto que permita entender los pasos dados durante el desarrollo para poder alcanzar ese tipo de soluciones finales. Si bien la aplicación en sí forma un conjunto cerrado y funcional y, a su vez, abierto y escalable a nueva funcionalidad. Algo fundamental, ya que de esta manera sirve como punto de partida para extenderse a ámbitos de actuación más concretos. Además, puede ser ampliada con más funcionalidad en pro de solucionar más problemas o dotar de mayor información al usuario.

\section{Problemas durante el desarrollo}

Cabe destacar que todos los objetivos concretos desarrollo o hitos de programación no han sido realmente resueltos. Esto ha sido debido a dos problemas encontrados durante el desarrollo, que han actuado como factores limitantes para poder alcanzar los objetivos 

El mayor problema a la hora de desarrollar la aplicación del proyecto ha residido en las limitaciones a la hora de el uso de Nmap. Si bien se ha logrado integrar de una manera clara sencilla y fácil Nmap (solventando el hecho de que no se trata de una librería sino de un software más complejo) y utilizarlo, exprimir toda su funcionalidad no ha sido posible. 
El principal problema a la hora de usar ciertas características de Nmap es que se requiere privilegios de superusuario. Esto genera un conflicto ineludible entre los dos objetivos de la aplicación. Entre obtener la mayor cantidad de información posible y generar una aplicación que puede utilizar cualquier usuario. 

En concreto, a la hora de obtener información más como las versiones de sistemas operativos de diferentes nodos o la dirección MAC del propio dispositivos mediante el uso de Nmap, requerimos de esa elevación de privilegios. La única forma de considerar elevación de privilegios ejecutar la aplicación en un sistema con con \textit{root} habilitado. 

Obviamente, si tenemos en cuenta que el \textit{target} de la aplicación son usuarios estándar sin conocimientos de sistemas informáticos, de programación o de seguridad, llegamos a la conclusión de que no van a tener sus dispositivos con este root habilitado. Esto al final limita el uso de Nmap a la hora de obtener información. Aún así Nmap sigue siendo la única herramienta que nos hubiera permitido obtener esta información de manera sencilla. 

El simple hecho de desarrollar funcionalidad para obtener información como versiones de sistemas operativos u otro tipo de información concreta, se escapa completamente del alcance de este Trabajo de Fin de Grado, ya que su su dificultad técnica resultan relativamente alta, haciendo del trabajo algo mucho más extenso. Por esto mismo este tipo de herramienta sólo están disponibles en software tan maduro y desarrollado como Nmap.

El segundo problema que ha surgido a la hora de desarrollar la aplicación ha sido el tema del rendimiento. Obtener información de una red requiere cierto tiempo. 

Una de las dificultades reside en que necesitamos un tiempo mínimo para analizar cada nodo de esa red. Si a la hora de escanear un nodo usamos un \textit{ping} a una dirección concreta para ver si está activa o no, este ping puede ser exitoso no en función del tiempo que dediquemos. Si se dedican, por poner un ejemplo, 50 milisegundos a ese ping puede que, debido al corto tiempo dedicado, obtengamos un falso negativo. En cambio si dedicamos un tiempo mayor, como de 300 milisegundos para ese ping, evitaremos esos falsos negativos, pero haremos con nuestra aplicación tarde más en escanear un host concreto.

Esto, al hablar de escanear un único nodo no parece tener relevancia, ya que estamos hablando del orden de milisegundos. Pero esto hay que sumar que solo se trata del paso inicial lanzar un escaneo. El escaneo completo con Nmap implica lanzar un proceso, ejecutar un binario, obtener una salida y leer esa salida. Aunque Nmap no es una aplicación que requiere un sistema de alto rendimiento, todo el proceso que se realiza para escanear un host requiere su tiempo de computación. Sobre todo hay que tener en cuenta para los casos en los que no estemos examinando uno u dos nodos, sino una gran cantidad de ellos, como es el caso de una red informática.

Una red estándar, como puede ser una red doméstica, normalmente suele tener una máscara de red \mintinline{kotlin}{255.255.255.0}. Obviamente esta máscara de red que indica es que tenemos 254 posibles direcciones para los nodos de esa red. A priori, uno puede asumir que las direcciones que va a repartir el router de esa red a los diferentes nodos estén entre los valores más bajos, pero esto no es algo que esté garantizado. Si queremos ver todos los dispositivos conectados en la red debemos analizar todas las posibles direcciones que puede tener esa re. 

Ya solo en ese caso concreto, algo sencillo en lo que no tendremos una gran cantidad de dispositivos, ya tenemos que analizar 254 direcciones. Si antes hablábamos de un pin de 300 milisegundos, a lo cual le podemos sumar otros tantos milisegundos para ejecutar todas las operaciones relacionadas con Nmap, podemos acercarnos al segundo en la ejecución. Un segundo no parece mucho, pero cuando hablamos de 254 veces esa operación entonces hablamos de un tiempo importante. 

Esto se complica mucho más para redes complejas como redes de universidades, redes en un entorno laboral o redes públicas grandes. Ya no solo es que las configuraciones concretas de estas redes puede hacer que Nmap no detecte toda la información correctamente, algo difícil controlar porque no podemos conocer el funcionamiento interno la como toda la configuración de una red a simple vista y modificar nuestros comandos para que ejecute de la mejor manera para cada red concreta. Por otra parte probablemente tengamos un número mayor de direcciones posibles. Esto hace que ejecutar un escaneo de esta red sea muchísimo más costoso a nivel de tiempo.

\section{Trabajo futuro}

La aplicación no resulta más que una prueba de concepto, una prueba de concepto de cómo se debe implementar una solución hacía un problema. La gran ventaja de esta prueba de concepto es que es altamente escalable. A la hora de su desarrollo han surgido varios problemas. Uno de los vectores de trabajo futuro puede ser examinar estudiar e implementar soluciones a estos problemas concretos. 

Para el problema de Nmap, se pueden buscar soluciones basadas en otras librerías para implementar las soluciones concretas que permitan obtener esos pedazos concretos de información. En la aplicación desarrollada ya se ha visto como a la hora de obtener por ejemplo la dirección MAC, se usa la información del protocolo de enrutamiento ARP, al haber sido incapaces de obtener la dirección mediante Nmap. 

También se han tenido más información de medios externos, como por ejemplo el fabricante de ese dispositivo, usando esa dirección de hardware y obteniendo en base a ella el fabricante desde una información de confianza, como es la información de la IANA. Algo parecido se ha hecho también, para adquirir información sobre los diferentes puertos y diferentes protocolos. Por ello, otro de los vectores de trabajo puede ser el encontrar fuentes externas que nos permitan ampliar la información mediante parámetros que ya hayamos obtenido nuestra aplicación.
